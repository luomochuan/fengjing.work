<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaWeb课程设计</title>
      <link href="/post/c2c1a33.html"/>
      <url>/post/c2c1a33.html</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb课程设计"><a href="#JavaWeb课程设计" class="headerlink" title="JavaWeb课程设计"></a>JavaWeb课程设计</h1><span id="more"></span><h2 id="一，git使用"><a href="#一，git使用" class="headerlink" title="一，git使用"></a>一，git使用</h2><h3 id="1-提交文件"><a href="#1-提交文件" class="headerlink" title="1.提交文件"></a>1.提交文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;文件&gt;  #添加一个文件到暂存区</span><br><span class="line">git add .*#添加全部文件到暂存区</span><br></pre></td></tr></table></figure><p>绿色代表处于暂存区，提交到本地库用commit命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;在a.txt中添加了helloword&quot;</span><br></pre></td></tr></table></figure><h3 id="2-查看"><a href="#2-查看" class="headerlink" title="2.查看"></a>2.查看</h3><ol><li>查看状态：命令是git status，可以查看当前状态。绿色代码表在暂存区，红色代表在工作区新建或者修改文件后未同步到暂存区。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><ol start="2"><li>查看提交记录：命令为git log。可以查看谁提交的，什么时候提交的，提交的是什么</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log  #查看详细记录</span><br><span class="line">git log --pretty=oneline  #查看第一行</span><br><span class="line">git reflog  #解决回退版本号后最新改动的版本号无法查看的问题</span><br></pre></td></tr></table></figure><h3 id="3-版本控制"><a href="#3-版本控制" class="headerlink" title="3.版本控制"></a>3.版本控制</h3><p>回退版本：git reset</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD`^   #回退一个版本</span><br><span class="line">git reset --hard HEAD`~2  #回退两个版本  ~后面指定回退几个版本</span><br><span class="line">git reset --hard &lt;指定版本号&gt;  #回退到指定版本</span><br></pre></td></tr></table></figure><h3 id="4-撤销修改"><a href="#4-撤销修改" class="headerlink" title="4.撤销修改"></a>4.撤销修改</h3><ol><li><p>撤销工作区内容</p><p> 命令：git checkout –&lt;文件名称&gt;</p><blockquote><p>注：只能撤销在工作区的修改，提交到暂存区的话无法进行撤销。另外只能撤销一步</p></blockquote> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --a.txt</span><br></pre></td></tr></table></figure></li><li><p>撤销暂存区内容</p><p> 命令: git reset HEAD 文件名</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD a.txt</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-删除文件"><a href="#5-删除文件" class="headerlink" title="5. 删除文件"></a>5. 删除文件</h3><blockquote><p>一句话，在工作去中先删除相关文件，然后将删除的文件提交的暂存区，接着将暂存区提交到本地库即可。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf b.txt</span><br><span class="line">git add b.txt</span><br><span class="line">git commit -m &quot;删除b.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="6-分支操作"><a href="#6-分支操作" class="headerlink" title="6.分支操作"></a>6.分支操作</h3><blockquote><p>分支好处：各个分支相互隔离，在某一分支上的操作不影响其他分支</p></blockquote><ol><li><p>创建分支</p><p> 命令：git branch &lt;分支名&gt;</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><p> 命令：git branch -D &lt;分支名&gt;</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D test2</span><br></pre></td></tr></table></figure><blockquote><p>注意，不能删除当前你所在的分支。必须先切换到主分支才能删除其他分支</p></blockquote></li><li><p>分支合并</p><p> 详细信息见下表</p></li><li><p>查看分支</p><p> 命令： git branch -v</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><p> 命令：git checkout &lt;分支名&gt;</p><p> 创建和切换分支一步完成：git checkout -b &lt;分支名&gt;</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout test2</span><br><span class="line">git checkout -b test2</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-分支合并"><a href="#6-分支合并" class="headerlink" title="6.分支合并"></a>6.分支合并</h3><ol><li>分支合并</li></ol><p>​    命令：git merge &lt;分支名称&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure><ol start="2"><li>解决冲突</li></ol><p>问题：主分支与分支中相同文件中相同行出现不同内容。例如：主分支中a.txt第五行为aaa而test分支中为bbb. </p><blockquote><p>先找出代码中冲突的部分，然后需要项目人员进行商讨，然后决定删除哪些内容。</p></blockquote><h3 id="7-远程仓库代码克隆下来"><a href="#7-远程仓库代码克隆下来" class="headerlink" title="7.远程仓库代码克隆下来"></a>7.远程仓库代码克隆下来</h3><p>​    命令：git clone &lt;远程仓库url&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/luomochuan/code.git</span><br></pre></td></tr></table></figure><h3 id="8-推送本地库到远程仓库"><a href="#8-推送本地库到远程仓库" class="headerlink" title="8.推送本地库到远程仓库"></a>8.推送本地库到远程仓库</h3><p>​    增加远程仓库链接</p><p>​    命令：git remote add origin &lt;远程仓库url&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/luomochuan/code.git</span><br></pre></td></tr></table></figure><p>​    将本地仓库推送到远程仓库</p><p>​    命令：git push origin &lt;分支&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><blockquote><p>注：远程上传有两种方案（据我所知，以下都是个人感受）</p><p>方案一：git使用SSH进行远程登录认证</p><p>​    对于此种方案来讲，只需进行一次SSH认证之后，以后每次上传到远程仓库就无需输入密码和口令。但是比起第二种方案而言安全性较差，idea关联github账户时，会报证书不可信等问题，但是方便使用。</p><p>方案二：使用token口令进行远程登录认证</p><p>​    使用此种方案安全性更强，但是当从别人远程下载或者上传时，git都会要求输入用户名和密码。同时，当从SSH认证人的仓库中拉取代码时，会出现认证失败的情形，需要设置以下命令才行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure></blockquote><p>以上两种方案在拉取代码到本地后，操作一致。都是在拉取到的文件目录内将文件进行修改，然后传递到本地库，最后上传到远程仓库。</p><h3 id="9-解决远程上传冲突"><a href="#9-解决远程上传冲突" class="headerlink" title="9.解决远程上传冲突"></a>9.解决远程上传冲突</h3><blockquote><p>场景：令狐冲和岳不群中的本地项目代码完全一致，但是两人都同时修改了b.txt，问两人在提交的时候谁的代码会成功？</p><p>答：若双方同时对文件的同一行进行修改，并且将此修改进行了push则谁先push谁成功。</p></blockquote><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h2><p><a href="https://imgtu.com/i/XD27Vg"><img src="https://s1.ax1x.com/2022/06/07/XD27Vg.png" alt="XD27Vg.png"></a></p><blockquote><p>岳不群</p><ol><li><p>搭建项目 jianfa，并且提交到自己的本地仓库</p></li><li><p>在岳不群的github上创建一个远程仓库jianfa</p></li><li><p>把本地库的jianfa项目push到岳不群自己的远程仓库</p><p> 增加远程仓库访问地址：git remote add origin 岳不群的github上jianfa项目的地址<br> 推送项目到远程仓库 ： git push origin master</p><p> 这里可能会出现权限认认证相关问题：解决方式就是给岳不群的github账号中添加一个token  （token值记得保存下来）</p><p> 具体解决方式参考钉钉群发送的md文件，或者下面的网址</p><p> <a href="https://blog.csdn.net/qq_38800316/article/details/120679506">https://blog.csdn.net/qq_38800316/article/details/120679506</a></p></li></ol><p>令狐冲</p><ol><li><p>拿到岳不群给的项目的地址，进行clone</p></li><li><p>令狐开始进行开发，开发完成之后进行本地库的提交操作</p></li><li><p>令狐冲将本地仓库的项目push到远程仓库</p><p> 这里可能会出现权限认认证相关问题：解决方式就是给令狐冲的github账号中添加一个token（token值记得保存下来）</p><p> 具体解决方式参考钉钉群发送的md文件，或者下面的网址</p><p> <a href="https://blog.csdn.net/qq_38800316/article/details/120679506">https://blog.csdn.net/qq_38800316/article/details/120679506</a></p></li></ol></blockquote><p>注：git使用SSH进行远程认证则不会出现上述问题。具体优劣分析上文。</p><h2 id="二、git以及github关联idea"><a href="#二、git以及github关联idea" class="headerlink" title="二、git以及github关联idea"></a>二、git以及github关联idea</h2><p>参考博客：<a href="https://blog.csdn.net/qq_36522306/article/details/94390588">https://blog.csdn.net/qq_36522306/article/details/94390588</a></p><ol><li><h3 id="git关联github"><a href="#git关联github" class="headerlink" title="git关联github"></a>git关联github</h3><p>  设置–&gt;版本控制–&gt;git。</p><p> 在这个窗口中，填写git可执行文件路径。一般在git安装的bin目录下，就可以找到git.exe文件。然后，点击旁边的测试按钮，如果出现安装git的版本号即为配置成功。然后点击应用，最后点击确定即可。</p><p> 其实，在git安装到windows操作系统后，idea是可以自动识别的，我们不需要进行配置，idea就可以自动识别出git的安装位置并使用。</p></li><li><h3 id="github登陆IDEA"><a href="#github登陆IDEA" class="headerlink" title="github登陆IDEA"></a>github登陆IDEA</h3></li></ol><p>​     设置–&gt;版本控制–&gt;github。</p><p>​    在右边点击加号，然后选择通过github账号登陆，接着在弹出的网页中点击<font size=3 color="red">Authorize in Github</font>按钮即可。</p>]]></content>
      
      
      <categories>
          
          <category> javaWeb课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win-server</title>
      <link href="/post/877b5fe8.html"/>
      <url>/post/877b5fe8.html</url>
      
        <content type="html"><![CDATA[<h1 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h1><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>DHCP（Dynamic Host Configuration Protocal）动态主机配置协议</p><p>1，使用场景</p><p>​    DHCP通常在局域网中使用，负责对IP地址进行集中管理和分配，是网络中的主机，动态的获得IP地址，网关地址，DNS服务器地址等信息，并提升IP地址的使用率。</p><p>2，工作过程</p><p>​    C/S通信模式。当客户端开机需要获取IP地址时，采用广播的形式进行申请。DHCP协议采用UDP作为传输协议，客户端发送广播消息到服务器68端口，服务器回应广播消息给客户端的67号端口。</p><p>​    DHCP客户端从DHCP服务器获取IP地址，主要通过四个阶段进行：发现、提供、选择、确认。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">client-&gt;&gt;server: DHCP discovery</span><br><span class="line">server-&gt;&gt;client: DHCP offer</span><br><span class="line">client-&gt;&gt;server: DHCP request</span><br><span class="line">server-&gt;&gt;client: DHCP ACK</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>DHCP offer阶段：如果网络中有多台DHCP服务器，所有服务器都会向客户端发送offer报文，这时候服务器只是提供一个分配建议，IP地址并没有分配给客户端。</p><p>DHCP request阶段：</p><p>​    客户端收到offer报文后，以广播的方式发送request报文。这个报文的选项字段中会被加入被选中DHCP服务器的IP地址和客户端需要的IP地址。</p><p>客户端只根据第一个收到的offer报文返回request报文。其他DHCP服务器在这次没有成功分配出的IP地址，可以分配给其他客户端不会被占用。</p><p>DHCP ACK阶段：</p><p>​    当服务器收到request报文后，被选中的服务会返回确认报文，确认已将地址分配给客户端。如果收到错误的request报文，服务器会返回NAK报文，表明地址不能够分配给该客户端。没有被客户端选中的DHCP服务器不会被响应。</p><p>​    在客户端收到服务器返回的ACK确认报文后，会一广播的形式发送ARP报文，探测是否有其他客户端正在使用服务器分配的IP地址。如果在规定时间内没有回应，客户端才使用这个IP地址。否则重新进行申请。</p></blockquote><p>3，租约更新</p><p>​    客户端成功获取IP地址后，可以通过发送release报文释放自己的IP地址。当服务器收到release报文后，会回收相应的IP地址并重新分配。地址租期默认8天，但是管理员可以自己进行设置。</p><p>​    当地址租期使用时间超过50%时，客户端会以单播的形式发送request报文来续租IP地址。如果客户端成功收到服务器发送的ACK报文，则会按相应的时长延长IP地址租期，若没收到，则继续使用。当使用时长超过87.5%时，客户端会议广播形式向服务器发送request报文来续租IP地址。如果客户端成功收到ACK报文则按相应时长延长IP地址租期，若没有收到，客户端继续使用，直到使用时长达到100%才会发送release报文来释放这个IP地址。并开始新的申请过程。</p><h2 id="DHCP中继代理与管理"><a href="#DHCP中继代理与管理" class="headerlink" title="DHCP中继代理与管理"></a>DHCP中继代理与管理</h2><p>方法：在连接客户端网络的路由器上开启DHCP中继代理功能，将DHCP广播报文变为单播报文发送出去。并且，将从服务器收到的单播报文变为广播报文返回给客户端。</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>1，什么是DNS？</p><p>DNS（Domain Name System）域名系统</p><p>作用：实现域名与IP地址的相互转换。</p><p>2，DNS域名解析</p><p>引言:因特网实际上只能通过IP地址来寻找服务器。在使用域名访问服务器时，需要先通过DNS，将域名解析为对应的IP地址，然后在通过IP地址访问目的服务器。</p><blockquote><p>注：由于DNS只负责域名解析，并不负责网络通信，因此就算没有DNS，网络仍然可以正常通信，只不过不能使用域名来访问服务器，必须使用IP地址来访问。</p></blockquote><p>4，DNS是如何完成域名解析的？</p><ol><li>主机访问一个网站的域名为 <a href="http://www.ncwu.edu.cn/">www.ncwu.edu.cn</a> 的服务器时，主机会首先查询本机的hosts文件，如果该文件中有该域名与IP的对应关系，就直接的到解析结果</li><li>如果hosts文件没有相关记录，则根据本机配置的DNS服务器IP地址，到本地域名服务器进行查询。如果该DNS服务器为区域ncwu.edu.cn的授权域名服务器，即负责该区域下的主机的域名解析，可以直接向主机返回权威应答。如果不是该区域的授权域名服务器，则查看缓存中是否有解析记录，如果有返回非权威应答。如果缓存中也没有解析记录，即本地DNS服务器无法解析，则查看是否设有转发域名服务器，如果有则将解析请求转发给转发域名服务器。</li><li>如果没有设有转发域名服务器，解析请求将被发送到根域名服务器</li><li>由于根域名服务器已将cn区域的解析委托给cn域的域名服务器dns.cn，因此根域名服务器值返回dns.cn对应的ip地址</li><li>本地域名服务器根据返回的IP地址向dns.cn发出解析请求</li><li>域名服务器dns.cn已将edu.cn区域的解析，委托给域名服务器dns.edu.cn，因此返回dns.edu.cn对应的IP地址</li><li>本地域名服务器根据返回的ip地址向dns.edu.cn发出解析请求</li><li>域名服务器dns.edu.cn已经将ncwu.edu.cn区域解析，委托给域名服务器dns.ncwu.edu.cn，因此返回dns.ncwu.edu.cn对应的ip地址</li><li>本地域名服务器根据返回的IP地址向dns.ncwu.edu.cn发出解析请求</li><li>域名服务器dns.ncwu.edu.cn是ncwu.edu.cn的授权域名服务器，将查询到 <a href="http://www.ncwu.edu.cn/">www.ncwu.edu.cn</a> 和对应的IP地址的对应关系向本地域名服务器提供权威应答</li><li>本地域名</li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算</title>
      <link href="/post/bdcfe473.html"/>
      <url>/post/bdcfe473.html</url>
      
        <content type="html"><![CDATA[<h1 id="云计算概述"><a href="#云计算概述" class="headerlink" title="云计算概述"></a>云计算概述</h1><h2 id="云计算是什么"><a href="#云计算是什么" class="headerlink" title="云计算是什么"></a>云计算是什么</h2><p>​    云计算，是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可以配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务)，这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应进行很少的交互。</p><span id="more"></span><h2 id="云计算工作模式"><a href="#云计算工作模式" class="headerlink" title="云计算工作模式"></a>云计算工作模式</h2><ol><li>公有云:厂商为你提供云主机，服务。</li><li>私有云：把公有云那一套搬到我自己的机房内，自己运营，不对外公开。</li><li>混合云：公有云和私有云一起混合使用</li><li>行业云/社区云/政务云：专门定位到一个行业的云服务。</li></ol><h2 id="云计算优势"><a href="#云计算优势" class="headerlink" title="云计算优势"></a>云计算优势</h2><ol><li>按需自助服务（就像水电燃一样）</li><li>广泛的网络接入（手机、电脑、三方终端设备）</li><li>资源池化（屏蔽掉不同厂商的物理硬件差异）</li><li>快速弹性伸缩（根据实际需求自动扩容）</li><li>可计量服务</li></ol><h2 id="云计算的服务模式"><a href="#云计算的服务模式" class="headerlink" title="云计算的服务模式"></a>云计算的服务模式</h2><p>IaaS:基础设施即服务 最底层的硬件资源,主要包括CPU(计算),硬盘(存储),网卡(网络)等.<br>PaaS:平台即服务 就是在第一层的基础上再加上操作系统,数据库等.<br>SaaS:软件即服务 在第三层的基础上装上我们想要的软件,我们可以直接使用.</p><p>DaaS: database as a service 数据库即服务 甲骨文公司私有</p><h2 id="云计算和虚拟化的区别"><a href="#云计算和虚拟化的区别" class="headerlink" title="云计算和虚拟化的区别"></a>云计算和虚拟化的区别</h2><blockquote><p>云计算底层采用虚拟化技术。</p><p>云计算提供一个管理平台对底层的云计算硬件资源进行管控。这些硬件资源上面采用虚拟化技术来运行服务。</p><p>云计算能不能对接物理机？</p><p>能，可以采用裸金属。</p><p>附：云计算公司采用的虚拟化技术都是开源的虚拟化技术。</p></blockquote><h1 id="华为FusionComputer"><a href="#华为FusionComputer" class="headerlink" title="华为FusionComputer"></a>华为FusionComputer</h1><h2 id="fusionsphere套件框架"><a href="#fusionsphere套件框架" class="headerlink" title="fusionsphere套件框架"></a>fusionsphere套件框架</h2><p><a href="https://imgtu.com/i/X0rVns"><img src="https://s1.ax1x.com/2022/06/06/X0rVns.png" alt="X0rVns.png"></a></p><p>ebackup是指BC manager ebackup</p><p>ultraVR：是一种虚拟化级别的容灾管理设备</p><p>BC Manager EReplication 是私有云容灾设备</p><h2 id="FusionCompute体系"><a href="#FusionCompute体系" class="headerlink" title="FusionCompute体系"></a>FusionCompute体系</h2><h3 id="CNA：computing-node-agent"><a href="#CNA：computing-node-agent" class="headerlink" title="CNA：computing node agent"></a>CNA：computing node agent</h3><p>名称：计算节点代理</p><p>只能物理部署，是安装在物理机上面的计算节点</p><h3 id="VRM：virtual-resource-management"><a href="#VRM：virtual-resource-management" class="headerlink" title="VRM：virtual resource management"></a>VRM：virtual resource management</h3><p>名称： 虚拟资源管理</p><blockquote><p>如何让物理主机具备虚拟化能力？</p><p>直接在物理主机上安装一个操作系统（CNA.iso）。CNA.iso是一个华为定制（裁剪过得）一个Linux操作系统。在管理主机上面安装VRM，vrm.iso也是一个定制Linux系统。</p></blockquote><h4 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h4><p>虚拟化部署：直接把VRM安装在CNA节点上面。官方建议如果CNA主机小于50台则进行虚拟化部署。</p><p>物理化部署：部署在物理机上面。如果CNA主机大于50台则进行物理化部署。</p><blockquote><p>注：单个虚拟机的内存不能超过物理机规格。</p></blockquote><h2 id="虚拟化技术分类"><a href="#虚拟化技术分类" class="headerlink" title="虚拟化技术分类"></a>虚拟化技术分类</h2><ol><li><p>基于软件的完全虚拟化 代表是VMware</p><p> 在基于软件的虚拟化中，虚拟机不知道自己是个虚拟机。虚拟机申请内存都是依靠软件来作为中间人申请的。</p></li><li><p>半虚拟化 代表是xen</p><p> 在半虚拟化中，虚拟机知道自己是虚拟机。虚拟机的操作先向嵌入物理机内核的domain申请资源，再由domain调用物理机资源来实现。</p></li><li><p>基于硬件辅助完全虚拟化 即Intel 的VT-X 和AMD的 AMD-V</p><p> 上面两种方法都是基于x86架构指令漏洞来实现的。因此，CPU厂商直接把敏感指令与内核指令不重叠的17条指令集成在CPU内，修补了漏洞。因此，产生了上述方案。</p></li></ol><h2 id="FC集群特性"><a href="#FC集群特性" class="headerlink" title="FC集群特性"></a>FC集群特性</h2><p>1.集群上创建虚拟机，可以使用集群配置，达到负载均衡的效果。</p><p>VCPUs=插槽数、<em>核数、</em>线程数</p><p>2.PV driver 半虚拟化驱动 virtio</p><h3 id="3-内存复用"><a href="#3-内存复用" class="headerlink" title="3.内存复用"></a>3.内存复用</h3><p>内存复用有三种技术：内存置换，内存气泡，内存共享</p><p>内存置换：就是将内存中暂时用不到的数据换入外存中。</p><p>内存气泡：虚拟监视器会在后台检测哪些虚拟机内存是空闲的，会将空闲的内存给到负载过重的，或者创建更多的虚拟机</p><p>内存共享：内存中的数据可以进行共享。对共享内存中的数据我们只能进行读操作，若要进行写操作需要再新开辟一段内存空间。</p><h3 id="4-NUMA"><a href="#4-NUMA" class="headerlink" title="4.NUMA"></a>4.NUMA</h3><p>前身：UMA Uniform memory access 一致性内存访问</p><p>NUMA：Non-Uniform memory access 非一致性内存访问</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HCIA_云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为堆叠技术</title>
      <link href="/post/89d83e3b.html"/>
      <url>/post/89d83e3b.html</url>
      
        <content type="html"><![CDATA[<h1 id="华为堆叠技术"><a href="#华为堆叠技术" class="headerlink" title="华为堆叠技术"></a>华为堆叠技术</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>概念：堆叠是指将多台交换机设备通过线缆连接后组合在一起，虚拟化成一台设备，是一种横向虚拟化技术。</p><span id="more"></span><blockquote><p>横向虚拟化：就是接入层交换机组合成一台交换机的技术</p><p>纵向虚拟化：核心层和接入层交换机组合在一起。即在核心交换机内添加接入层交换机的管理程序，可以实现管理接入层交换机</p></blockquote><p>可靠组网：</p><p>​    1、VRRP+MSTP（传统技术）</p><p>​    2、堆叠+链路捆绑（推荐）</p><p>厂商的堆叠技术：</p><p>​    华为：CSS（框式）、iStack（盒式） 两者只是名称不同，其实都一样。</p><p>​    思科：VSS</p><p>​    华三：IRF</p><p>​    锐捷：VSU</p><blockquote><p>注：堆叠技术是厂商的私有技术，用于堆叠的设备一般是同一系列，最后是同一型号。</p></blockquote><h2 id="华为堆叠原理"><a href="#华为堆叠原理" class="headerlink" title="华为堆叠原理"></a>华为堆叠原理</h2><p>堆叠原理示意图</p><p><a href="https://imgtu.com/i/o2HARf"><img src="https://s4.ax1x.com/2021/12/08/o2HARf.png" alt="o2HARf.png"></a></p><p>堆叠基本概念：</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>主交换机（Master）</td><td>主交换机负责管理整个堆叠域，堆叠域中只有一台主交换机</td></tr><tr><td>备交换机（Standby）</td><td>备交换机是主交换机的备份交换机。当主交换机故障时，备份交换机会接替主交换机的工作。一个堆叠域中只有一台备交换机。</td></tr><tr><td>从交换机（slave）</td><td>出主备交换机外的所有交换机。从交换机主要用于业务转发。从交换机数量越多，堆叠系统转发能力越强。注：华为CE12800系列只能堆叠两台交换机</td></tr><tr><td>堆叠域（domain）</td><td>交换机通过堆叠链路连接在一起形成一个堆叠。这些成员交换机的集合就是一个堆叠域</td></tr><tr><td>堆叠成员ID（memberID）</td><td>堆叠成员交换机的编号，用来标识和管理成员交换机。堆叠中所有成员交换机的堆叠成员ID都是唯一的</td></tr><tr><td>堆叠优先级</td><td>堆叠优先级是成员交换机的一个属性，用于选举角色。</td></tr><tr><td>堆叠物理成员端口</td><td>被配置为堆叠模式的端口，用于堆叠成员交换机之间的连接</td></tr><tr><td>堆叠端口</td><td>一种专用于堆叠的逻辑端口，需要和堆叠物理成员端口绑定。以个堆叠端口可以与一个或多个物理端口绑定，提高链路带宽和可靠性。</td></tr></tbody></table><blockquote><p>总结：堆叠域和ospf在以太网中的区域类似。堆叠的交换机优先级最高的是主交换机，次之备份，最后从交换机。</p><p>注意：每台交换机上面的堆叠逻辑端口最多有两个。</p></blockquote><h2 id="堆叠建立"><a href="#堆叠建立" class="headerlink" title="堆叠建立"></a>堆叠建立</h2><h3 id="堆叠建立流程"><a href="#堆叠建立流程" class="headerlink" title="堆叠建立流程"></a>堆叠建立流程</h3><p>堆叠建立的过程主要包括以下四个阶段：</p><ol><li>物理连接及软件配置：根据网络需求，选择适当的连接拓扑，组建堆叠网络，并进行相关软件配置</li><li>主交换机选举：成员交换机之间相互发送竞争报文，并根据选举规则，选出堆叠系统的主交换机</li><li>拓扑收集：主交换机收集搜有队员交换机的信息并计算拓扑。如果成员交换机的堆叠成员ID冲突，主交换机将为冲突交换机重新分配ID</li><li>稳态运行：主交换机将整个堆叠系统的拓扑信息同步给所有成员交换机，并选举一台备交换机。</li></ol><h3 id="角色选举"><a href="#角色选举" class="headerlink" title="角色选举"></a>角色选举</h3><p>规则如下：</p><ol><li>运行转台比较，最先启动的交换机为主交换机</li><li>堆叠优先级比较，优先级最高的为主交换机</li><li>软件版本比较，版本高的为主交换机</li><li>（仅CE12800&amp;12800E涉及）主控板数量比较，有两块主控板的交换机比只有一块主控板的交换机优先竞争主交换机</li><li>桥MAC地址比较，桥MAC地址最小的为主交换机</li></ol><h3 id="版本同步"><a href="#版本同步" class="headerlink" title="版本同步"></a>版本同步</h3><p>堆叠具有版本同步的功能，组成堆叠的成员交换机不需要具有相同的软件版本，只需要版本间兼容即可。主交换机选举完成后，如果其他交换机与主交换机版本不一样，其他交换机会从主交换机上面下载系统软件，然后新的系统软件重启并重新加入堆叠。</p><h3 id="配置同步"><a href="#配置同步" class="headerlink" title="配置同步"></a>配置同步</h3><p>堆叠具有严格的配置文件同步机制，用来保证堆叠中的多台交换机能够像一台设备一样在网络中工作。</p><ul><li>堆叠建立时，成员交换机在启动开始阶段使用各自的配置文件启动。启动完成后，备，从交换机会将本设备的堆叠相关配置合并到主交换机的配置文件中，形成堆叠系统的配置文件</li><li>堆叠正常启动后，主交换机作为堆叠系统的管理节点，负责将用户的配置同步给其他交换机，从而使堆叠内个成员的配置随时保持一致。</li></ul><p>通过即时同步，堆叠中的所有交换机均保持相同的配置文件，及时主交换机出现故障，其他交换机依然能够按照相同的配置文件执行各项功能。</p><h2 id="堆叠系统的登陆"><a href="#堆叠系统的登陆" class="headerlink" title="堆叠系统的登陆"></a>堆叠系统的登陆</h2><p>堆叠建立后，所有网络具有同一配置，所以使用堆叠系统中任何一台的console口登陆均可以。</p><h2 id="堆叠合并与分裂"><a href="#堆叠合并与分裂" class="headerlink" title="堆叠合并与分裂"></a>堆叠合并与分裂</h2><h3 id="堆叠合并"><a href="#堆叠合并" class="headerlink" title="堆叠合并"></a>堆叠合并</h3><p><a href="https://imgtu.com/i/oWa5Yq"><img src="https://s4.ax1x.com/2021/12/09/oWa5Yq.png" alt="oWa5Yq.png"></a></p><p>​    堆叠合并是指稳定运行的两个堆叠系统合并成一个新的堆叠系统。堆叠系统合并时，两个堆叠系统的主交换机进行竞争，选举出更优的作为新的堆叠系统的主交换机（选举规则则与选举主交换机的规则一致）</p><p>​    竞争胜出的主交换机所在的堆叠系统将保持原有主，备角色和配置不变，业务也不会收到影响；而另一个堆叠系统的所有成员将重新启动后加入新堆叠启动。</p><h3 id="堆叠分裂"><a href="#堆叠分裂" class="headerlink" title="堆叠分裂"></a>堆叠分裂</h3><p>堆叠建立后，主交换机和其他成员交换机之间定时发心跳保温来维持堆叠系统的状态。当堆叠线缆或设备发生故障时将发生故障，可能会导致交换机之间失去通信。</p><p>解释：因为一个堆叠系统所有交换机的IP地址和MAC地址的配置都一样，所以一个堆叠的交换机分裂出去后仍保持原有配置，则网络中会有两台相同的ip和MAC相同放入交换机，则会导致通信故障。针对此问题，提出了堆叠双主检测技术。</p><h2 id="堆叠硬件要求"><a href="#堆叠硬件要求" class="headerlink" title="堆叠硬件要求"></a>堆叠硬件要求</h2><p>​    1、堆叠卡堆叠</p><p>​    堆叠卡堆叠是早期堆叠的形式。它需要有厂商的堆叠卡和堆叠线。</p><p>​    2、业务口堆叠</p><p>​    使用万兆的SP+集成电缆进行堆叠。</p><p>​    3、连接注意事项：</p><p>​        使用堆叠卡进行堆叠连接时需要将堆叠线交叉连接。</p><p>​        业务口堆叠要求逻辑堆叠端口进行交叉连接。</p><h2 id="华为堆叠配置"><a href="#华为堆叠配置" class="headerlink" title="华为堆叠配置"></a>华为堆叠配置</h2><h3 id="使用堆叠卡进行配置"><a href="#使用堆叠卡进行配置" class="headerlink" title="使用堆叠卡进行配置"></a>使用堆叠卡进行配置</h3><p>步骤一：</p><p>​    关闭电源开关，将switch下电，安装模块后插卡，再将设备上电</p><p>步骤二：使能堆叠功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">sysname switchA</span><br><span class="line">stack enable</span><br><span class="line"></span><br><span class="line">sys</span><br><span class="line">sysname switchB</span><br><span class="line">stack enable</span><br><span class="line">其他同理</span><br></pre></td></tr></table></figure><p>注：使用堆叠功能后，需要重启设备才能生效。堆叠功能生效后才能配置堆叠ID和堆叠优先级。</p><p>步骤三：</p><p>​    配置堆叠ID和堆叠优先级。堆叠ID缺省值为0，堆叠优先级缺省值为100</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack slot 0 priority 200</span><br><span class="line">stack slot 0 renumber 1</span><br><span class="line">stack slot 0 renumber 2</span><br></pre></td></tr></table></figure><h3 id="使用业务口进行配置"><a href="#使用业务口进行配置" class="headerlink" title="使用业务口进行配置"></a>使用业务口进行配置</h3><p>步骤一：配置逻辑堆叠端口并添加物理成员端口。</p><p>配置switchA的业务口G0/0/27、G0/0/28为物理成员端口，并加入到相应的逻辑堆叠端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">sysname switchA</span><br><span class="line">int stack-port 0/1</span><br><span class="line">port int g0/0/27 enable</span><br><span class="line">quit</span><br><span class="line">int stack-port 0/2</span><br><span class="line">port int g0/0//28 enable</span><br><span class="line">quit</span><br><span class="line"><span class="meta">#</span><span class="bash">另一台交换机同样思路</span></span><br></pre></td></tr></table></figure><p>步骤二：配置堆叠ID和堆叠优先级。堆叠ID缺省值为0，堆叠优先级缺省值为100.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">交换机A</span></span><br><span class="line">stack slot 0 priority 200     #修改主交换机的堆叠优先级为200，大于其他成员优先级。堆叠ID采用缺省值0</span><br><span class="line">stack slot 0 renumber 1#堆叠优先级采用缺省值100.修改堆叠ID为1</span><br><span class="line">stack slot 0 renumber 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap使用</title>
      <link href="/post/30bf2354.html"/>
      <url>/post/30bf2354.html</url>
      
        <content type="html"><![CDATA[<h1 id="nmap使用"><a href="#nmap使用" class="headerlink" title="nmap使用"></a>nmap使用</h1><h2 id="1、nmap基础入门"><a href="#1、nmap基础入门" class="headerlink" title="1、nmap基础入门"></a>1、nmap基础入门</h2><h3 id="1、nmap安装"><a href="#1、nmap安装" class="headerlink" title="1、nmap安装"></a>1、nmap安装</h3><p>Windows下直接去<a href="https://nmap.org/download.html">https://nmap.org/download.html</a>  下载后点击exe文件安装即可。</p><p>对于Linux系统，只需在管理员界面或者sudo 后面接命令安装即可。命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -VhU https://nmap.org/dist/nmap-7.70-1.x86_64.rpm  #rpm包是centos系列的包，ubuntu的应该是deb. nmap-7.70-1.x86_64.rpm是版本号</span><br></pre></td></tr></table></figure><p>当然，Linux系统也可以进行源码编译安装。</p><span id="more"></span><h3 id="2、nmap发现主机的原理"><a href="#2、nmap发现主机的原理" class="headerlink" title="2、nmap发现主机的原理"></a>2、nmap发现主机的原理</h3><blockquote><p>原理：使用ICMP echo request来进行探测</p><p>过程：当我们输入完nmap指令后，机器会首先判断命令行中是否包含域名，如果包含域名，则先去DNS域名解析服务器进行域名解析，然后向解析到的IP地址发送ICMP echo request报文探测主机是否存活。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nmap scanme.nmap.org </span><br><span class="line"><span class="meta">#</span><span class="bash">结果如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Nmap scan report <span class="keyword">for</span> scanme.nmap.org (45.33.32.156)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Host is up (0.40s latency).</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Other addresses <span class="keyword">for</span> scanme.nmap.org (not scanned): 2600:3c01::f03c:91ff:fe18:bb2f</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Not shown: 987 closed ports</span></span><br><span class="line"><span class="meta">#</span><span class="bash">PORT      STATE    SERVICE</span></span><br><span class="line"><span class="meta">#</span><span class="bash">22/tcp    open     ssh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">80/tcp    open     http</span></span><br><span class="line"><span class="meta">#</span><span class="bash">135/tcp   filtered msrpc</span></span><br><span class="line"><span class="meta">#</span><span class="bash">139/tcp   filtered netbios-ssn</span></span><br><span class="line"><span class="meta">#</span><span class="bash">445/tcp   filtered microsoft-ds</span></span><br><span class="line"><span class="meta">#</span><span class="bash">593/tcp   filtered http-rpc-epmap</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1434/tcp  filtered ms-sql-m</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4444/tcp  filtered krb524</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5800/tcp  filtered vnc-http</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5900/tcp  filtered vnc</span></span><br><span class="line"><span class="meta">#</span><span class="bash">8129/tcp  filtered unknown</span></span><br><span class="line"><span class="meta">#</span><span class="bash">39929/tcp  open     nping-echo</span></span><br><span class="line"><span class="meta">#</span><span class="bash">31337/tcp open     Elite</span></span><br></pre></td></tr></table></figure><p>nmap进行探测之前要把域名通过DNS服务器解析成IP地址，我们也可以使用指定的DNS服务器进行解析。参数: –dns-servers</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --dns-servers 114.114.114.114 scanme.nmap.org</span><br></pre></td></tr></table></figure><blockquote><p>对于已经知道主机存活或者防火墙开启的机器，可以使用-Pn参数来停止探测之前的ICMP请求。从而可以不触发报警机制。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn scanme.nmap.org</span><br></pre></td></tr></table></figure><p>对于默认端口范围，并不能满足日常工作需要。我们可以使用-p m-n来指定扫描端口范围为m-n之间的所有端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 1-1000 scanme.nmap.org</span><br></pre></td></tr></table></figure><h3 id="3、端口状态"><a href="#3、端口状态" class="headerlink" title="3、端口状态"></a>3、端口状态</h3><p>我们通过上面四中方式的扫描可以发现端口状态有好几种。他们分别表示什么状态呢？</p><blockquote><p>-open 表示端口处于开放状态</p><p>-Closed 表示端口处于关闭状态</p><p>-Filterd 表示端口处于过滤无法收到返回包</p><p>-UnFilterd 表示端口收到返回的probe，但是无法确认</p><p>-opend/UnFilterd 表示端口处于未开放或者是过滤状态</p><p>-Closed/UnFilterd 表示端口处于关闭或者是未过滤状态</p></blockquote><h3 id="4、扫描技术查看"><a href="#4、扫描技术查看" class="headerlink" title="4、扫描技术查看"></a>4、扫描技术查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -h</span><br></pre></td></tr></table></figure><blockquote><p>SCAN TECHNIQUES:<br>  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans<br>  -sU: UDP Scan<br>  -sN/sF/sX: TCP Null, FIN, and Xmas scans<br>  –scanflags <flags>: Customize TCP scan flags<br>  -sI &lt;zombie host[:probeport]&gt;: Idle scan<br>  -sY/sZ: SCTP INIT/COOKIE-ECHO scans<br>  -sO: IP protocol scan<br>  -b <FTP relay host>: FTP bounce scan</p></blockquote><h2 id="2、使用nmap查看服务指纹"><a href="#2、使用nmap查看服务指纹" class="headerlink" title="2、使用nmap查看服务指纹"></a>2、使用nmap查看服务指纹</h2><p>原理：nmap通过向目标主机发送多个UDP与TCP数据包并分析其相应来进行操作系统指纹识别工作</p><blockquote><p>使用此方法扫描的主机只能是没有防火墙或者安全措施比较差的机器。要不然会返回host seem down的消息。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 220.181.38.148</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a><a href="https://imgtu.com/i/oNjw5j"><img src="https://z3.ax1x.com/2021/12/02/oNjw5j.png" alt="oNjw5j.png"></a></h3><h3 id="nmap侵略性探测"><a href="#nmap侵略性探测" class="headerlink" title="nmap侵略性探测"></a>nmap侵略性探测</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A -v -T4 192.168.1.103</span><br></pre></td></tr></table></figure><p>参数解析：</p><p>​    -A代表扫描全部信息</p><p>​    -v代表扫描版本</p><p>​    -T4代表使用4个CPU同时进行探测，减少时间，</p><p>侵略性探测命令2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sC -sV -O 192.168.1.103</span><br></pre></td></tr></table></figure><p>参数解释：</p><p>​    sC参数表示nmap使用默认脚本进行探测</p><p>​    sV表示探测目标机器上的服务信息</p><p>​    O表示探测目标机器的操作系统信息</p><blockquote><p>注：使用此条命令也会留下你主机的指纹。</p></blockquote><p><a href="https://imgtu.com/i/oNjDGn"><img src="https://z3.ax1x.com/2021/12/02/oNjDGn.png" alt="oNjDGn.png"></a></p><h2 id="3、主机发现"><a href="#3、主机发现" class="headerlink" title="3、主机发现"></a>3、主机发现</h2><h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><p>ping命令大家都比较熟悉，这里就不在讲解。</p><h3 id="nmap主机发现"><a href="#nmap主机发现" class="headerlink" title="nmap主机发现"></a>nmap主机发现</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP CIDR   #CIDR是网络里面的无类别路由</span><br><span class="line">nmap -sP 192.168.1.0/24 </span><br><span class="line">nmap -sn 192.168.1.0/24  #nmap发现命令的另一种方式，结果和上面一样</span><br></pre></td></tr></table></figure><p>原理：就是ping命令的升级版（脚本）。扫描过程中同时还使用了TCP SYN扫描 echo Request来探测主机存活。</p><p><a href="https://imgtu.com/i/oNjBPs"><img src="https://z3.ax1x.com/2021/12/02/oNjBPs.png" alt="oNjBPs.png"></a></p><h3 id="nmap主机发现，结果输出"><a href="#nmap主机发现，结果输出" class="headerlink" title="nmap主机发现，结果输出"></a>nmap主机发现，结果输出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn CIDR -oX test.txt</span><br></pre></td></tr></table></figure><p>-oX就是将结果存储在test.txt文件</p><h2 id="4、端口扫描技巧"><a href="#4、端口扫描技巧" class="headerlink" title="4、端口扫描技巧"></a>4、端口扫描技巧</h2><h3 id="对某个端口进行探测"><a href="#对某个端口进行探测" class="headerlink" title="对某个端口进行探测"></a>对某个端口进行探测</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p80 scanme.nmap.org</span><br><span class="line">nmap -p80, 135 scanme.nmap.org</span><br></pre></td></tr></table></figure><h3 id="对某个范围的端口进行扫描"><a href="#对某个范围的端口进行扫描" class="headerlink" title="对某个范围的端口进行扫描"></a>对某个范围的端口进行扫描</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 80-100 scanme.nmap.org</span><br></pre></td></tr></table></figure><h3 id="对所有端口进行扫描"><a href="#对所有端口进行扫描" class="headerlink" title="对所有端口进行扫描"></a>对所有端口进行扫描</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p- scanme.nmap.org</span><br></pre></td></tr></table></figure><h3 id="指定协议探测端口"><a href="#指定协议探测端口" class="headerlink" title="指定协议探测端口"></a>指定协议探测端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p T:25,U:53 scanme.nmap.org</span><br></pre></td></tr></table></figure><p>命令解释：探测TCP的25号端口，UDP的53号端口。</p><h3 id="通过协议名来扫描端口"><a href="#通过协议名来扫描端口" class="headerlink" title="通过协议名来扫描端口"></a>通过协议名来扫描端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p smtp scanme.nmap.org</span><br></pre></td></tr></table></figure><h3 id="通过名称范围扫描"><a href="#通过名称范围扫描" class="headerlink" title="通过名称范围扫描"></a>通过名称范围扫描</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p s* scanme.nmap.org</span><br></pre></td></tr></table></figure><h2 id="NSE脚本使用"><a href="#NSE脚本使用" class="headerlink" title="NSE脚本使用"></a>NSE脚本使用</h2><p>NSE：Nmap脚本引擎，内置很多可以用来扫描的、针对特定任务的脚本。通过NSE可以不断拓展Nmap的扫描策略，加强Nmap的功能。</p><p>Nmap中使用–script参数来指定调用的脚本，并且脚本存储在Nmap安装路径下的script文件夹下，对于kali Linux系统存储在/usr/share/nmap/script/下。</p><h3 id="NSE的使用"><a href="#NSE的使用" class="headerlink" title="NSE的使用"></a>NSE的使用</h3><p>使用Nmap探测web服务的title信息。-nmap –script脚本名称 目标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script http-title scanme.nmap.org</span><br></pre></td></tr></table></figure><p>使用nmap探测http服务的http头</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script http-headers scanme.nmap.org</span><br></pre></td></tr></table></figure><h3 id="NSE分类使用"><a href="#NSE分类使用" class="headerlink" title="NSE分类使用"></a>NSE分类使用</h3><p>对于目标使用多个分类脚本进行探测，可以更快的找到目标的信息和弱点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV --script vuln 目标</span><br></pre></td></tr></table></figure><p>使用Nmap中发现和版本信息进行探测，使用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV --script=&quot;version,discovery&quot; 目标主机</span><br></pre></td></tr></table></figure><p>使用Nmap除了exploit分类之外的其他分类进行探测</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV --script=&quot;not exploit&quot; 目标</span><br></pre></td></tr></table></figure><p>使用Nmap中http*的脚本，但是除了（http-brute和http-slowlors）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV --script &quot;(http*) and not (http-slowlors and http-brute)&quot; 目标</span><br></pre></td></tr></table></figure><h3 id="NSE调试功能使用"><a href="#NSE调试功能使用" class="headerlink" title="NSE调试功能使用"></a>NSE调试功能使用</h3><p>使用Nmap中exploit, 但是在使用exploit的同时开启调试模式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV --script exploit -d 3 --script-trace 目标</span><br></pre></td></tr></table></figure><blockquote><p>注：-d(debug 范围是0~9)</p></blockquote><h3 id="NSE参数的使用"><a href="#NSE参数的使用" class="headerlink" title="NSE参数的使用"></a>NSE参数的使用</h3><p>使用nmap的http-title脚本，并且指定使用对应的User-Afent</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV --script http-title --script-args http.useragent=&quot;Mozilla 999&quot; 目标主机</span><br></pre></td></tr></table></figure><blockquote><p>–script-args 表示使用脚本参数</p></blockquote><h3 id="NSE更新"><a href="#NSE更新" class="headerlink" title="NSE更新"></a>NSE更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script-update</span><br></pre></td></tr></table></figure><h3 id="NSE脚本分类"><a href="#NSE脚本分类" class="headerlink" title="NSE脚本分类"></a>NSE脚本分类</h3><p>去<a href="https://nmap.org/nsedoc/">https://nmap.org/nsedoc/</a>  查看</p><h2 id="nmap对特定网卡进行探测"><a href="#nmap对特定网卡进行探测" class="headerlink" title="nmap对特定网卡进行探测"></a>nmap对特定网卡进行探测</h2><p>适用的情形：一个计算机上面有两张网卡，且两张网卡对应不同的网络</p><h3 id="指定网卡进行探测"><a href="#指定网卡进行探测" class="headerlink" title="指定网卡进行探测"></a>指定网卡进行探测</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -e interface CIDR</span><br></pre></td></tr></table></figure><p>查看当前nmap可使用的网卡状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --iflist</span><br></pre></td></tr></table></figure><h2 id="对比扫描结果"><a href="#对比扫描结果" class="headerlink" title="对比扫描结果"></a>对比扫描结果</h2><p>适用场景：需要将两次探测结果进行对比</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ndiff -h   #查看帮助</span><br><span class="line">ndiff file1 file2 #file1和file2是nmap扫描结果的xml格式。</span><br></pre></td></tr></table></figure><blockquote><p>注：ndiff比较的是两个xml文件</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SD-WAN</title>
      <link href="/post/d5067876.html"/>
      <url>/post/d5067876.html</url>
      
        <content type="html"><![CDATA[<h1 id="SD-WAN"><a href="#SD-WAN" class="headerlink" title="SD-WAN"></a>SD-WAN</h1>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora使用教程</title>
      <link href="/post/64297bf3.html"/>
      <url>/post/64297bf3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Typora教程"><a href="#Typora教程" class="headerlink" title="Typora教程"></a>Typora教程</h1><h2 id="结构类操作"><a href="#结构类操作" class="headerlink" title="结构类操作"></a>结构类操作</h2><h3 id="多级标题"><a href="#多级标题" class="headerlink" title="多级标题"></a>多级标题</h3><blockquote><p>使用快捷键Ctrl + 1~6 代表一到六级标题</p><p>清除：Ctrl + 0</p></blockquote><span id="more"></span><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><blockquote><p>使用方法：*或-后面加空格 </p><p>注：无序列表可以嵌套</p><p>例子：在无序列表中插入有序列表</p><ul><li>青菜</li><li>水果<ol><li>苹果     #使用tab键可以升级，使用shift+tab可以降级</li><li>梨子</li></ol></li><li>肉</li></ul></blockquote><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><blockquote><p>键位：-[]</p><p>注意：</p><ol><li><p>-，[、]后都一定要有空格</p></li><li><p>无快捷键，可以通过鼠标操作</p><p> 选中文字-&gt;段落-&gt;任务列表</p><ul><li><input disabled="" type="checkbox"> CCIE技术点</li><li><input disabled="" type="checkbox"> python</li></ul></li></ol></blockquote><h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><blockquote><p>创建方式：|学号|姓名|性别| ——&gt;回车</p><p>注意：添加一行，只需Ctrl+回车</p><table><thead><tr><th>学号</th><th>姓名</th><th>性别</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></blockquote><h2 id="代码类操作"><a href="#代码类操作" class="headerlink" title="代码类操作"></a>代码类操作</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><blockquote><p>创建操作：<code>(反引号)java是一门好语言</code>(反引号)</p><p>快捷键：Ctrl shift + `</p><p>​    <code>java是一门好语言</code></p></blockquote><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote><p>快捷键：Ctrl shift + k</p><p>创建操作：```(反引号)语言</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;java是一门好语言&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><blockquote><p>创建方式：！<a href=""></a> –&gt;选择图片</p><p>快捷键：ctrl shift + i</p><p>也可以使用图床</p></blockquote><img src="Typora使用教程.assets/屏幕截图 2021-11-11 231106.png" style="zoom:33%;" /><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><blockquote><p>使用Typora画图就是使用mermaid画图</p><p>方法：```mermaid</p><p>使用mermaid画图十分方便，我们在输命令的时候在下方可以实时生成</p></blockquote><h3 id="画流程图"><a href="#画流程图" class="headerlink" title="画流程图"></a>画流程图</h3><blockquote><p>竖向流程图：</p><p>关键词：graph TD</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD; </span><br><span class="line">A--&gt;B;</span><br><span class="line">A--&gt;C;</span><br><span class="line">B--&gt;D;</span><br></pre></td></tr></table></figure><blockquote><p>横向流程图：</p><p>关键词：graph LR</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line"></span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure><h3 id="标准流程图"><a href="#标准流程图" class="headerlink" title="标准流程图"></a>标准流程图</h3><blockquote><p>标准流程图（竖向）</p><p>关键词：flow    st-&gt;op-&gt;cond</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><blockquote><p>标准流程图（横向）</p><p>关键词：st(right)-&gt;op(right)-&gt;cond</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><blockquote><p>语法解释：<code>[*]</code> 表示开始或者结束，如果在箭头右边则表示结束。</p><p>关键词：stateDiagram</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">    [*] --&gt; s1</span><br><span class="line">    s1 --&gt; [*]</span><br></pre></td></tr></table></figure><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><blockquote><p>语法解释：<code>&lt;|--</code> 表示继承，<code>+</code> 表示 <code>public</code>，<code>-</code> 表示 <code>private</code>，学过 Java 的应该都知道</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">      Animal &lt;|-- Duck</span><br><span class="line">      Animal &lt;|-- Fish</span><br><span class="line">      Animal &lt;|-- Zebra</span><br><span class="line">      Animal : +int age</span><br><span class="line">      Animal : +String gender</span><br><span class="line">      Animal: +isMammal()</span><br><span class="line">      Animal: +mate()</span><br><span class="line">      class Duck&#123;</span><br><span class="line">          +String beakColor</span><br><span class="line">          +swim()</span><br><span class="line">          +quack()</span><br><span class="line">      &#125;</span><br><span class="line">      class Fish&#123;</span><br><span class="line">          -int sizeInFeet</span><br><span class="line">          -canEat()</span><br><span class="line">      &#125;</span><br><span class="line">      class Zebra&#123;</span><br><span class="line">          +bool is_wild</span><br><span class="line">          +run()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h3><blockquote><p>关键词：sequenceDiagram</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Alice-&gt;&gt;John: Hello Jhon, how are you?</span><br><span class="line">John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure><blockquote><p>UML时序图源码复杂样例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><blockquote><p>甘特图一般用来表示项目的计划排期，目前在工作中经常会用到。</p><p>语法也非常简单，从上到下依次是图片标题、日期格式、项目、项目细分的任务。</p><p>关键词：gantt</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">title 工作计划</span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line">section Section</span><br><span class="line">A task          :a1,2020-01-01,30d</span><br><span class="line">Another task    :after a1 ,20d</span><br><span class="line">Task in sec:2020-01-12, 12d</span><br><span class="line">another task    :24d</span><br></pre></td></tr></table></figure><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><blockquote><p>饼图只需要输入字段名和字段数值即可，它会自动计算比例</p><p>关键词：pie</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">title Key elements in Product X</span><br><span class="line">&quot;calcium&quot; : 42.96</span><br><span class="line">&quot;potassium&quot; : 50.05</span><br><span class="line">&quot;magnesium&quot; : 10.01</span><br><span class="line">&quot;Iron&quot; : 5</span><br></pre></td></tr></table></figure><h3 id="旅行图："><a href="#旅行图：" class="headerlink" title="旅行图："></a>旅行图：</h3><blockquote><p>旅行图就是按照时间先后顺序将你所做的事情输入进去即可。还可以使用数字大小表示事情的优先级</p><p>格式：事务：优先级数字：人物</p><p>关键词：journey</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">journey</span><br><span class="line">  title My working day</span><br><span class="line">  section Go to work</span><br><span class="line">    Make tea: 5: Me</span><br><span class="line">    Go upstairs: 3: Me</span><br><span class="line">    Do work: 1: Me, Cat</span><br><span class="line">  section Go home</span><br><span class="line">    Go downstairs: 5: Me</span><br><span class="line">    Sit down: 3: Me</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思科平台交换方式</title>
      <link href="/post/8aa65066.html"/>
      <url>/post/8aa65066.html</url>
      
        <content type="html"><![CDATA[<p>概述：思科平台支持的交换方式有三种：进程交换、快速交换、CEF（基于拓扑的交换）。</p><span id="more"></span><h1 id="CEF的负载均衡"><a href="#CEF的负载均衡" class="headerlink" title="CEF的负载均衡"></a>CEF的负载均衡</h1><p>基于目的地负载均衡实际上是通过对目的地和源IP地址进行HASH后实现的。也就是说实际上是基于源、目的地址对进行负载均衡。这种方法在大规模网络环境环境中很有用。</p><blockquote><p>什么叫做基于源、目的地址对进行负载均衡？</p><p>当主机A去访问另一台主机B的时候，即使他们中间有多条路径可供选择，他们将始终沿着分组第一次走过的路径进行传递。当主机A去访问同样拥有多条可达路径的主机C时，将会更换另一条路径。也就是说这种模式下，路由器在转发数据包的时候是将源目的地址捆绑起来进行查询的。</p></blockquote><h2 id="带标签报文的负载均衡"><a href="#带标签报文的负载均衡" class="headerlink" title="带标签报文的负载均衡"></a>带标签报文的负载均衡</h2>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科—交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LDP</title>
      <link href="/post/79bf7643.html"/>
      <url>/post/79bf7643.html</url>
      
        <content type="html"><![CDATA[<h1 id="标签交换协议LDP"><a href="#标签交换协议LDP" class="headerlink" title="标签交换协议LDP"></a>标签交换协议LDP</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo aaa;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/post/9520183a.html"/>
      <url>/post/9520183a.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四课时：过滤数据"><a href="#第四课时：过滤数据" class="headerlink" title="第四课时：过滤数据"></a>第四课时：过滤数据</h1><p>主要内容：select和where语句</p><p>注：在select语句中，数据根据where子句指定的搜索条件进行过滤。</p><span id="more"></span><p>where子句的位置：在同时使用order by 和where子句时，应该让order by位于where之后，                否则会产生错误。</p><p>解释：where子句会将查询到的数据放到内存中。where之后的子句都是在内存中的数据进行操    作。</p><h2 id="where子句的使用"><a href="#where子句的使用" class="headerlink" title="where子句的使用"></a>where子句的使用</h2><h3 id="如何使用引号"><a href="#如何使用引号" class="headerlink" title="如何使用引号"></a>如何使用引号</h3><p>单引号用来限定字符串。如果将值与字符串类型的列进行比较，就需要限定引号。如果与数值列进行比较就不需要单引号。</p><h3 id="范围值检查——between"><a href="#范围值检查——between" class="headerlink" title="范围值检查——between"></a>范围值检查——between</h3><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">between</span> <span class="operator">&lt;</span>开始值<span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&lt;</span>结束值<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>这两个值必须使用关键字进行分割。between匹配范围内的所有值，包括起始值与结束值。</p><h3 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h3><p>概念：在一个列不包含值时，称其包含空值NULL。</p><p>NULL：无值（no value）它与字段包含0、空字符串或仅包含空格不同。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> cust_email <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p>select 语句有一个特殊的where子句，可用来检查具有NULL值的列。这个子句是IS NULL</p></blockquote><blockquote><p>null与不匹配解释：</p><p>​    假设一列有三个值age=11，age=null，age=10。现在需要筛选出年龄不为10的人，则只会筛选出age=11，不会筛选出age=null。</p><p>原文解释：</p><p>​    在通过过滤选择出不具有特定值的行时，你可能希望返回具有NULL值的行。但是，不行。因为未知(NULL)具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有NULL的行。</p></blockquote><h1 id="第五课时：高级数据过滤"><a href="#第五课时：高级数据过滤" class="headerlink" title="第五课时：高级数据过滤"></a>第五课时：高级数据过滤</h1><blockquote><p>主要内容：组合where子句。NOT和IN操作符</p></blockquote><h2 id="组合where语句"><a href="#组合where语句" class="headerlink" title="组合where语句"></a>组合where语句</h2><p>SQL允许多个where语句。这些子句有两种使用方式。即以AND子句或OR子句方式使用。</p><h3 id="AND操作符"><a href="#AND操作符" class="headerlink" title="AND操作符"></a>AND操作符</h3><p>作用：给多个where子句添加附加条件。相当于逻辑运算中的“与”操作。</p><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">and</span> <span class="operator">&lt;</span>条件<span class="number">2</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">and</span> prod_price <span class="operator">&lt;=</span><span class="number">4</span>;</span><br></pre></td></tr></table></figure><h3 id="OR操作符"><a href="#OR操作符" class="headerlink" title="OR操作符"></a>OR操作符</h3><p>作用：相当于逻辑运算中的“或运算”</p><blockquote><p>注：许多DBMS在OR WHERE子句第一个条件得满足的情况下，就不再继续计算第二个条件（即第一个条件满足，直接打印结果）</p></blockquote><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">or</span> <span class="operator">&lt;</span>条件<span class="number">2</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> vend_id<span class="operator">=</span><span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">or</span> vend_id<span class="operator">=</span><span class="string">&#x27;BRS01&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>where子句可以包含任意数目的AND和OR操作符，并且允许两者结合使用。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> vend_id<span class="operator">=</span><span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">or</span> vend_id<span class="operator">=</span><span class="string">&#x27;BRS01&#x27;</span> <span class="keyword">AND</span> proc_price<span class="operator">&gt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>上述这条命令，我们是想先执行or操作符，然后再执行AND操作符。但是执行结果确实先执行and操作符再执行or操作符。这是因为SQL默认的执行方式会先执行and决定的。我们可以做如下修改，即可达到我们的目的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> （vend_id<span class="operator">=</span><span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">or</span> vend_id<span class="operator">=</span><span class="string">&#x27;BRS01&#x27;</span>）<span class="keyword">AND</span> proc_price<span class="operator">&gt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h3><p>作用：用来指定条件范围，范围中每个条件都可以进行匹配</p><p>使用方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> vend_id <span class="keyword">IN</span> (<span class="string">&#x27;DLL01&#x27;</span>,<span class="string">&#x27;BRS01&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注：IN的作用于OR相同。上述语句可以用OR操作符改写成：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where vend_id=&#x27;DLL01&#x27; OR vend_id=&#x27;BRS01&#x27;</span><br></pre></td></tr></table></figure><h3 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h3><p>作用：否定其后所限的任何条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where NOT vend_id=&#x27;DLL01&#x27;</span><br></pre></td></tr></table></figure><p>上述命令的意思是：不匹配vend_id中关于DLL01的行</p><h1 id="第六课时"><a href="#第六课时" class="headerlink" title="第六课时"></a>第六课时</h1><p>​    我们通过前两节的学习可以知道操作符都是针对已知某一个完整的字段进行过滤。这样就会产生一个问题：当我们查找的数据在一个文本中，并且数据还可能不连续，那么就无法使用操作符来进行过滤。所以需要通配符来解决。</p><h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><p>​    我们在进行通配符使用讲解之前先来了解几个概念：什么是通配符，什么是搜索模式、以及一些注意事项。</p><p>通配符：用来匹配值的一部分的特殊字符。它在mysql中必须与LIKE操作符进行连用。</p><p>搜索模式：由字面值、通配符或者两者组合构成的搜索条件。</p><blockquote><p>注：通配符实际上是SQL的where子句中有特殊含义的字符。在搜索子句中使用通配符，必须使用LIKE操作符。因为LIKE指示DBMS，后跟的搜索模式是利用通配符进行的过滤而不是简单的相等匹配进行比较。</p></blockquote><h3 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h3><p>作用：百分号%表示任何字符出现任意字数。它在不同位置有不同的含义：在需要匹配字符串后面时，是匹配该字符串后面的字符串开头的字段(Finsh%)；在需要匹配字符串的两边时(%finsh%)，是中间含有该字符串的字段；在两个字符中间时（y%F），是匹配以y开头F结尾的字段。我们可以将%理解为：先匹配含有给定字符串，然后根据位置筛选结果这一过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where prod_name LIKE &#x27;y%F&#x27;</span><br></pre></td></tr></table></figure><p>如果字段使用空格来填补内容，上述命令就会出现筛选错误的情况。我们可以使用以下两种方法来进行解决：</p><p>方法一：在F后面再加一个%，形成y%F%这样也能匹配F后面的空格。</p><p>方法二：使用函数将字段中空格清除后再进行匹配</p><blockquote><p>说明：区分大小写</p><p>​    根据DBMS的不同及其配置，搜索可以区分大小写。</p><p>另外，通配符可以在搜索模式中任意使用，并且可以使用多个通配符</p></blockquote><h3 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h3><p>作用：和上面的百分号作用一样。但是下划线通配符一次只能匹配一个字符，而不是匹配多个字符。例如，当我们使用下划线通配符进行两个字符的匹配时，就需要使用’__’而不是’ _ ‘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where prod_name LIKE &#x27;__ inch teddy bear&#x27;;</span><br></pre></td></tr></table></figure><h3 id="方括号（-）通配符"><a href="#方括号（-）通配符" class="headerlink" title="方括号（[]）通配符"></a>方括号（[]）通配符</h3><p>作用：该通配符通常用来指定一个字符集，他必须匹配指定位置（通配符的位置）的一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where cust_contact LIKE &#x27;[jm]%&#x27;;</span><br></pre></td></tr></table></figure><p>上述例子是匹配以j或m开头的内容，但是只能匹配一个字符，多一个都不可以。当我们不想匹配以j或m的内容可使用^即[ ^jm].</p><h1 id="七：创建计算字段"><a href="#七：创建计算字段" class="headerlink" title="七：创建计算字段"></a>七：创建计算字段</h1><h2 id="算术计算"><a href="#算术计算" class="headerlink" title="算术计算"></a>算术计算</h2><p>目前支持的运算符为+ - * / %</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select quantity*item_price as expanded_price;</span><br></pre></td></tr></table></figure><p>上述是一个乘法的例子。我们在使用运算符时可以结合select语句使用，可以使结果直接进行运算后显示出来。</p><h2 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h2><p>拼接：将值联结到一起</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql必知必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mpls</title>
      <link href="/post/45c7d1a9.html"/>
      <url>/post/45c7d1a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="MPLS原理"><a href="#MPLS原理" class="headerlink" title="MPLS原理"></a>MPLS原理</h1><h2 id="MPLS介绍"><a href="#MPLS介绍" class="headerlink" title="MPLS介绍"></a>MPLS介绍</h2><p>现状：由于路由器性能能力已经比较强，MPLS转发增强能力已经不明显。</p><p>全称：Multi-Proctocol Lable Switching 多协议标签交换</p><p>Muti-Proctocol：支持多三层协议，如IP、IPv6、IPX等等</p><p>Lable Switching:在所承载的报文前面加上标签栈，基于标签做转发。</p><span id="more"></span><blockquote><p>MPLS是一种新的转发机制，数据在MPLS网络中是以根据标签信息进行转发</p><p>一般而言，MPLS的标签对应目的地址（路有前缀）</p><p>MPLS依赖IP路由及CEF交换，基于报头头部的标签进行数据转发。</p><p>MPLS能够支持或者说承载多种三层协议。</p></blockquote><h2 id="MPLS构建过程"><a href="#MPLS构建过程" class="headerlink" title="MPLS构建过程"></a>MPLS构建过程</h2><p>1、路由器运行IGP路由协议，维护RIB表及CEF表</p><p>2、路由器运行标签分发协议（LDP），维护LIB表</p><p>3、路由器更新CEF表，同时维护LFIB表（路由器转发依据表）</p><blockquote><p>注：LIB表是建立在CEF表之上的。</p></blockquote><h2 id="MPLS小结"><a href="#MPLS小结" class="headerlink" title="MPLS小结"></a>MPLS小结</h2><ul><li>采用MPLS，可避免ip路由逐跳转发情况，减少对数据包的深入分析，借助标签建立二层的快速转发路径，使得数据沿着一条预先建立的路径快速转发。</li><li>数据包在进入MPLS网络的入口路由器上被进行一次三层查找，而在此后的LSR只是进行简单的标签交换动作，无需进一步分析三层信息</li><li>每个LSR必须在数据转发之前建立好LIB（标签信息库），及LFIB（标签转发信息数据库）。当LSR收到一个标签数据帧时，将数据帧中的标签在LFIB表中进行查找，在根据LFIB表中指示的相关动作多标签进行压入、弹出、交换、移除等动作。</li></ul><h2 id="MPLS架构"><a href="#MPLS架构" class="headerlink" title="MPLS架构"></a>MPLS架构</h2><p><a href="https://imgtu.com/i/oFZsHS"><img src="https://z3.ax1x.com/2021/11/24/oFZsHS.png" alt="oFZsHS.png"></a></p><h3 id="控制层面"><a href="#控制层面" class="headerlink" title="控制层面"></a>控制层面</h3><p>交换三层路由信息（如ospf/ISIS/BGP等）及标签（如TDP（思科私有）、LDP（共有）、BGP（多协议拓展）及RSVP）</p><h3 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h3><p>基于标签进行数据转发</p><h2 id="MPLS设备"><a href="#MPLS设备" class="headerlink" title="MPLS设备"></a>MPLS设备</h2><p>LSR标签交换路由器</p><h2 id="FEC转发等价类"><a href="#FEC转发等价类" class="headerlink" title="FEC转发等价类"></a>FEC转发等价类</h2><ul><li>在转发过程中，具有相同处理方式的一组数据，可通过地址、隧道、Qos等方式来标识，通常在一台设备上，对于一个FEC分配相同的标签。</li><li>属于一个FEC的流量具有相同的转发方式、转发路径</li></ul><h3 id="保留的标签"><a href="#保留的标签" class="headerlink" title="保留的标签"></a>保留的标签</h3><p>标签0-15都是被保留的标签。以下是有特定用途的标签</p><ul><li>​    标签0 显示空标签</li><li>​    标签3 隐式空标签</li><li>​    标签1 路由器报警标签</li><li>​    标签14 OAM报警标签</li></ul><p>其余的标签都是保留的。</p><h2 id="环路避免机制"><a href="#环路避免机制" class="headerlink" title="环路避免机制"></a>环路避免机制</h2><ul><li>LDP的环路避免机制依赖于IGP。因为LFIB表是根据路由表RIB产生FIB表产生的。</li><li>如果出现了环路（一般是IGP出了问题，如静态路由配置错误），标签头中的TTL将防止标签包无止境的转发</li><li>标签头中的TTL与IP头中的TTL是一样的，通常拷贝自IP头中的TTL值（当一个MPLS包进入网络时），这就是MPLS的环路避免机制。</li></ul><p>总结：依赖IGP协议和复制ip报头中TTL值来防止环路。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell</title>
      <link href="/post/4592b2fd.html"/>
      <url>/post/4592b2fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="初识shell"><a href="#初识shell" class="headerlink" title="初识shell"></a>初识shell</h1><h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h2><p>shell是一个程序，采用C语言编写，是用户和Linux内核沟通的桥梁。它既是一种命令语言，又是一种解释性的编程语言。通过一个图表来查看一下shell的作用。</p><span id="more"></span><p><a href="https://imgtu.com/i/oiChY6"><img src="https://z3.ax1x.com/2021/11/24/oiChY6.jpg" alt="oiChY6.jpg" style="zoom:33%;" /></a></p><p>解释：</p><p>​    内核：为软件服务，接受用户或软件指令驱动硬件，完成工作。</p><p>​    shell：命令解释器</p><p>​    user：用户接口，对接用户</p><h2 id="什么是shell脚本"><a href="#什么是shell脚本" class="headerlink" title="什么是shell脚本"></a>什么是shell脚本</h2><p>shell脚本就是将完成一个任务的所有命令按照执行的先后顺序，自上而下写入到一个文本文件中，然后给与执行权限。</p><h1 id="shell语法"><a href="#shell语法" class="headerlink" title="shell语法"></a>shell语法</h1><p>使用shell脚本安装一个nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget pcre-devel zlib-devel</span><br><span class="line">wget http://nginx.org/download/nginx-1.16.0.tar.gz</span><br><span class="line">tar xf nginx-1.16.0.tar.gz</span><br><span class="line">cd nginx-1.16.0</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="一、如何书写一个shell脚本"><a href="#一、如何书写一个shell脚本" class="headerlink" title="一、如何书写一个shell脚本"></a>一、如何书写一个shell脚本</h2><p>shell脚本的命名：</p><p>名字有意义，最好不要用a、b、C、1、2这种方式命名；虽然在Linux系统中没有文件拓展名这种概念，依然建议你使用.sh .py结尾。同时，名字不要太长，最好能在30字以内。</p><p>shell脚本格式：</p><p>shell脚本开头必须指定脚本运行环境。以#！这个特殊符号来组合。如：#！/bin/bash指定该脚本是运行在/bin/bash下。</p><p>shell中的注释使用#号。</p><p>在创建一个shell脚本时，应该使用#注释表明脚本的用途、创建时间、作者、作者的联系方式等内容。</p><p>我们上面安装nginx的脚本就需要优化为下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1) 定义脚本的执行环境</span></span><br><span class="line"><span class="meta">#</span><span class="bash">！/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2）表明作者和脚本信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash">作者：风景</span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建时间：2021年11月19日20:52:20</span></span><br><span class="line"><span class="meta">#</span><span class="bash">脚本版本：1.0·</span></span><br><span class="line"><span class="meta">#</span><span class="bash">脚本描述：安装nginx1.16.0</span></span><br><span class="line"></span><br><span class="line">yum -y install wget pcre-devel zlib-devel</span><br><span class="line">wget http://nginx.org/download/nginx-1.16.0.tar.gz</span><br><span class="line">tar xf nginx-1.16.0.tar.gz</span><br><span class="line">cd nginx-1.16.0</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><blockquote><p>注：#！不是注释，他指定使用哪个解释器来运行shell脚本。</p></blockquote><h2 id="二、执行shell脚本的2种方式"><a href="#二、执行shell脚本的2种方式" class="headerlink" title="二、执行shell脚本的2种方式"></a>二、执行shell脚本的2种方式</h2><p>1、给与权限执行。        2、在解释器中执行，不需要给权限</p><h3 id="1、给予权限执行"><a href="#1、给予权限执行" class="headerlink" title="1、给予权限执行"></a>1、给予权限执行</h3><blockquote><p>1、在绝对路径中执行脚本</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/shell/helloworld.sh</span><br></pre></td></tr></table></figure><blockquote><p>2、以相对路径执行脚本</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /shell/</span><br><span class="line">./helloworld.sh</span><br></pre></td></tr></table></figure><p>注：编写完脚本后需要增加执行权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x helloworld.sh</span><br></pre></td></tr></table></figure><h3 id="2、使用解释器执行"><a href="#2、使用解释器执行" class="headerlink" title="2、使用解释器执行"></a>2、使用解释器执行</h3><p>就是在脚本文件前面加上指定的解释器，然后执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash nginx_install.sh</span><br></pre></td></tr></table></figure><h2 id="三、shell中的特殊符号"><a href="#三、shell中的特殊符号" class="headerlink" title="三、shell中的特殊符号"></a>三、shell中的特殊符号</h2><blockquote><p>~: 家目录 #cd ~代表用户进入家目录</p><p>!: 执行历史命令 !! 执行上一条命令</p><p>$0：当前脚本的文件名</p><p>$n：第n个位置参数</p><p>$*：传递给脚本或函数的所有参数，$*会将这些参数视为一个整体</p><p>$@：传递给脚本或函数的所有参数，$@会将所有参数当作同一字符串中的多个独立的单词</p><p>: 转义字符</p><p>*: 星号是shell中的通配符，匹配所有</p><p>?: 问号是shell中的通配符 匹配除回车以外的一个字符</p><p>;: 分号可在shell中一行执行多个命令，命令之间用分号分割。</p><p>``: 反引号 ，命令中执行命令 echo “today is <code>date +%F</code>“</p><p>‘’:单引号，脚本出现的字符串可以用单引号引起来，但是不同于双引号的是，单引号不解释变量。</p><p>“”:双引号，脚本出现的字符串可以用双引号引起来</p><p>$: 变量中取内容符</p><p>$#：脚本运行时携带的参数个数</p><p>$?：最近一个命令的退出状态码</p><p>$$：当前shell的进程ID（PID）</p><p>$!：最近一个后台命令的PID</p><p>IFS：内部字段分隔符，IFS环境变量定义了shell用作字段分隔符的一系列字符。默认情况下，shell会将下列字符当做字段分隔符：</p><ul><li><p>空格</p></li><li><p>制表符</p></li><li><p>换行符</p></li></ul><p>&amp;: 后台执行</p><p>&amp;&gt;：将STDERR和STDOUT的输出重定向到同一个输出文件</p><p>&amp;-：要关闭文件描述符，可以将它重定向到特殊符号&amp;-</p><p>.：点操作符，点操作符是source命令的别名，它会在shell上下文中执行点操作符指定的脚本，而不是创建一个新的shell。</p></blockquote><h2 id="四、shell中管道运用"><a href="#四、shell中管道运用" class="headerlink" title="四、shell中管道运用"></a>四、shell中管道运用</h2><blockquote><p>管道符在shell中使用是最多的，很多组合命令都需要通过命令来组合完成输出。管道其实就是上一个命令的输出作为下一个命令的输入</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep ssh</span><br><span class="line">root       1136  0.0  0.1 112984  4328 ?        Ss   10:28   0:00 /usr/sbin/sshd -D</span><br><span class="line">root       8902  0.0  0.1 158940  5548 ?        Ss   10:29   0:00 sshd: centos [priv]</span><br><span class="line">centos     8906  0.0  0.0 158940  2520 ?        S    10:29   0:00 sshd: centos@pts/1</span><br><span class="line">root       9181  0.0  0.0 112828   988 pts/1    S+   10:39   0:00 grep --color=auto ssh</span><br></pre></td></tr></table></figure><h2 id="五、重定向的使用"><a href="#五、重定向的使用" class="headerlink" title="五、重定向的使用"></a>五、重定向的使用</h2><h3 id="输入重定向："><a href="#输入重定向：" class="headerlink" title="输入重定向："></a>输入重定向：</h3><blockquote><p>将输入的结果重定向到另一个文件中（会覆盖原来的内容）：&gt;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo aaa &gt; a.txt</span><br></pre></td></tr></table></figure><blockquote><p>将前面命令输出的结果追加到后面的文件中（不会覆盖原来的内容）：&gt;&gt;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo bbb &gt;&gt; a.txt</span><br></pre></td></tr></table></figure><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><blockquote><p>重定向输出 &lt;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; /etc/passwd</span><br><span class="line">50</span><br></pre></td></tr></table></figure><blockquote><p>重定向追加输出：&lt;&lt;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; eof</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">aaa</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">eof</span></span><br></pre></td></tr></table></figure><p>将eof字符之前的字符作为输入传递给cat命令，然后查看输入结果。</p><h3 id="输入输出重定向同时使用"><a href="#输入输出重定向同时使用" class="headerlink" title="输入输出重定向同时使用"></a>输入输出重定向同时使用</h3><blockquote><p>命令格式：命令 &lt; 文件1 &gt; 文件2</p><p>功能：命令把文件1的内容作为标准输入，把文件2作为标准输出。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  /etc/passwd  &lt; a  &gt; b.txt</span><br></pre></td></tr></table></figure><p>将文件passwdt输入重定向到a，输出重定向到b.txt文件</p><h2 id="六、shell做数学运算"><a href="#六、shell做数学运算" class="headerlink" title="六、shell做数学运算"></a>六、shell做数学运算</h2><h3 id="命令-expr"><a href="#命令-expr" class="headerlink" title="命令: expr"></a>命令: expr</h3><blockquote><p>expr 命令只能做整数类型的四则以及求余运算。如果有浮点数参与运算会报错。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">做加法运算</span></span><br><span class="line">expr 1 + 2</span><br><span class="line"><span class="meta">#</span><span class="bash">做减法运算</span></span><br><span class="line">expr 1 - 2</span><br><span class="line"><span class="meta">#</span><span class="bash">做减法运算</span></span><br><span class="line">expr 1 \* 2</span><br><span class="line"><span class="meta">#</span><span class="bash">做除法运算</span></span><br><span class="line">expr 10 / 2</span><br><span class="line"><span class="meta">#</span><span class="bash">做求余运算</span></span><br><span class="line">expr 10 % 3</span><br></pre></td></tr></table></figure><h3 id="命令：let"><a href="#命令：let" class="headerlink" title="命令：let"></a>命令：let</h3><blockquote><p>let 命令的使用方式优点类似于C语言程序的两个数的四则运算, 同时也是只能进行整数运算。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a=11+11</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure><h3 id="命令：bc"><a href="#命令：bc" class="headerlink" title="命令：bc"></a>命令：bc</h3><blockquote><p>他是一个文本类型的计算程序，是一个交互式的指令。在bc环境下可以进行以下操作。+ 加法、减法、乘法、除法、指数、余数。它使用scale来设定小数位，还可以使用ibase和obase来进行其他进制的计算。对于bc的补充，我们通过bc –help发现bc后面还能接文件名</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用scale设定小数位</span></span><br><span class="line">scale=3</span><br><span class="line">1/3</span><br><span class="line"><span class="meta">#</span><span class="bash">使用ibase设定进制</span></span><br><span class="line">//将十六进制的A7输出为十进制，注意英文只能大写</span><br><span class="line">echo &quot;ibase=16;A7&quot; |bc</span><br><span class="line"><span class="meta">#</span><span class="bash">bc后面跟文件名</span></span><br><span class="line">more calc.txt</span><br><span class="line">3+2</span><br><span class="line">4+5</span><br><span class="line">bc calc.txt</span><br><span class="line">5</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h3 id="命令：echo"><a href="#命令：echo" class="headerlink" title="命令：echo"></a>命令：echo</h3><blockquote><p>在shell中，可以使用echo后面加上 $（（ ））进行运算</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $((10**3))</span><br></pre></td></tr></table></figure><h2 id="脚本退出"><a href="#脚本退出" class="headerlink" title="脚本退出"></a>脚本退出</h2><p>命令：exit</p><p>exit的返回值范围为0~255,默认返回值为0，代表程序已经正常执行并返回。当然我们也可以在范围内自定义返回值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这是一个测试返回值的脚本</span></span><br><span class="line"><span class="meta">#</span><span class="bash">！/bin/bash</span></span><br><span class="line">echo &quot;haha&quot;</span><br><span class="line">exit 10</span><br></pre></td></tr></table></figure><p>执行完上述代码后，回到命令行界面，执行echo $?查看返回值为几即可。</p><h1 id="shell格式化输出"><a href="#shell格式化输出" class="headerlink" title="shell格式化输出"></a>shell格式化输出</h1><h2 id="一、echo命令介绍"><a href="#一、echo命令介绍" class="headerlink" title="一、echo命令介绍"></a>一、echo命令介绍</h2><p>功能：将内容输出到默认显示设备</p><p>语法：echo [-ne] [字符串]</p><p>补充说明：echo会将输入的字符串送到标准输出。输出的字符串之间以空白字符隔开，并在最后加上换行号</p><blockquote><p>命令选项：</p><p>​    -n 不要在最后自动换行</p><p>​    -e 若字符串中出现以下字符，则特别加以处理，而不能把他当成一般文字输出</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!水果商店代码</span></span><br><span class="line">echo -e &quot;\t\t\t\tFruits Shop&quot;</span><br><span class="line">echo -e &quot;\t1) Apple&quot;</span><br><span class="line">echo -e &quot;\t2) Banana&quot;</span><br><span class="line">echo -e &quot;\t3) Orange&quot;</span><br></pre></td></tr></table></figure><h2 id="二、颜色输出"><a href="#二、颜色输出" class="headerlink" title="二、颜色输出"></a>二、颜色输出</h2><p>脚本中echo显示内容带颜色显示，echo显示带颜色，需要使用参数-e</p><blockquote><p>格式如下：</p><p>echo -e “033[字体背景颜色;文字颜色m字符串\033[0m”</p><p>例如</p><p>echo -e “\033[41;36m somthing here \033[0m”</p><p>其中41的位置代表底色，36的位置代表字的颜色</p><p>1，字背景颜色和文字颜色之间是英文的””</p><p>2, 文字颜色后面有个m</p><p>3，字符串前后可以没有空格，如果有的话，输出同样有空格</p><p>注：字背景色请参考以下链接</p><p><a href="https://blog.csdn.net/yanghao23/article/details/6249291?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164438688616780255261178%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164438688616780255261178&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-6249291.pc_search_result_cache&amp;utm_term=Liunx%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/yanghao23/article/details/6249291?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164438688616780255261178%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164438688616780255261178&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-6249291.pc_search_result_cache&amp;utm_term=Liunx%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2&amp;spm=1018.2226.3001.4187</a></p></blockquote><h2 id="shell基本输入"><a href="#shell基本输入" class="headerlink" title="shell基本输入"></a>shell基本输入</h2><h3 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h3><p>默认接受键盘的输入，回车符代表输入结束</p><blockquote><p>命令选项</p><p>-p 打印信息</p><p>-t 限定时间</p><p>-s 不回显</p><p>-n 输入字符个数</p></blockquote><p>例子：一个登陆界面的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!这是一个登陆界面的脚本</span></span><br><span class="line">clear</span><br><span class="line">echo -n -e &quot;Login:&quot;</span><br><span class="line">read acc</span><br><span class="line">echo -n -e &quot;Password:&quot;</span><br><span class="line">read pw</span><br><span class="line"></span><br><span class="line">echo &quot;account: $acc password: $pw &quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li>变量介绍</li><li>变量分类</li><li>变量管理</li></ul><h2 id="一、变量介绍"><a href="#一、变量介绍" class="headerlink" title="一、变量介绍"></a>一、变量介绍</h2><p>为什么要有变量？    </p><p>​    为了存取数据的方便</p><p>什么是变量？    </p><p>​    变量是编程中最常用的一种临时在内存中存取数据的方式。</p><blockquote><p>当我们在脚本中定义变量存值的时候，可以从以下方面看到变化：</p><p>1，内存占用：如果存的是一个字符则占用一个字节，如果存的是字符串则是字符串的长度加一个字节长度（\0是一个特殊的字符，代表字符串的结束）</p><p>2，变量名和内存关系：计算机中会将对应的内存空间和变量名绑定在一起，此时代表这段内存空间已被程序占用，其他程序不可复用然后将变量名对应的值存在对应的内存空间里</p></blockquote><h2 id="二、变量分类"><a href="#二、变量分类" class="headerlink" title="二、变量分类"></a>二、变量分类</h2><ol><li>本地变量：用户私有变量，只有本用户可以使用，保存在家目录下的.bash_profile、.bashrc文件中</li><li>全局变量：所有用户都可以使用，保存在/etc/profile、/etc/bashrc文件中</li><li>用户自定义变量：用户自定义，比如脚本中的变量</li></ol><h2 id="三、定义变量"><a href="#三、定义变量" class="headerlink" title="三、定义变量"></a>三、定义变量</h2><h3 id="2-1）定义变量"><a href="#2-1）定义变量" class="headerlink" title="2.1）定义变量"></a>2.1）定义变量</h3><p>变量格式：变量名=值</p><p>在shell编程中的变量名和等号之间不能有空格</p><blockquote><p>变量命名规则：</p><p>​    命名只能使用英文字母，数字和下划线，收个字符不能为数字</p><p>​    中间不能有空格，可以使用下划线</p><p>​    不能使用标点符号</p><p>​    不能使用bash里的关键字</p></blockquote><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VAR1=1</span><br><span class="line">age=18</span><br><span class="line">name=&#x27;jia&#x27;</span><br><span class="line">score=88.8</span><br></pre></td></tr></table></figure><blockquote><p>注：字符串要用单引号或双引号引起来</p></blockquote><h3 id="2-2-读取变量名"><a href="#2-2-读取变量名" class="headerlink" title="2.2)读取变量名"></a>2.2)读取变量名</h3><p>读取变量内容符：$</p><p>读取方法：$变量名</p><blockquote><p>变量内容读出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[centos8.4@centos8 ~]$ echo $name</span><br><span class="line">jia</span><br><span class="line">[centos8.4@centos8 ~]$ echo $score</span><br><span class="line">88.8</span><br><span class="line">[centos8.4@centos8 ~]$ echo $age</span><br><span class="line">18</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-3）取消变量unset"><a href="#2-3）取消变量unset" class="headerlink" title="2.3）取消变量unset"></a>2.3）取消变量unset</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unset name</span><br><span class="line">echo $name</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-定义全局变量export"><a href="#2-4-定义全局变量export" class="headerlink" title="2.4)定义全局变量export"></a>2.4)定义全局变量export</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export name=&quot;jia&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">上述设置的变量其实都是一次性变量，系统重启就会丢失</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果希望本地变量或者全局变量可以永久使用，可以；将需要设置的变量写入变量文件即可</span></span><br></pre></td></tr></table></figure><h3 id="2-5）定义永久变量"><a href="#2-5）定义永久变量" class="headerlink" title="2.5）定义永久变量"></a>2.5）定义永久变量</h3><p>只需要写入相应配置文件即可</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>基本数组</li><li>关联数组</li><li>案例分享</li></ul><h2 id="一、基本数组"><a href="#一、基本数组" class="headerlink" title="一、基本数组"></a>一、基本数组</h2><p>​    数组可以让用户一次赋予多个值，需要读取数据时只需通过索引调用就可以方便读出了</p><h3 id="1-1-数组语法"><a href="#1-1-数组语法" class="headerlink" title="1.1 数组语法"></a>1.1 数组语法</h3><blockquote><p>数组名称=（元素1 元素2 元素3 ……）</p></blockquote><h3 id="1-2-数组读出"><a href="#1-2-数组读出" class="headerlink" title="1.2 数组读出"></a>1.2 数组读出</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;数组名称[索引]&#125;</span></span><br></pre></td></tr></table></figure><p>索引默认是元素在数组中的排队编号，默认第一个从0开始，和C语言一样</p></blockquote><h3 id="1-3-数组赋值"><a href="#1-3-数组赋值" class="headerlink" title="1.3 数组赋值"></a>1.3 数组赋值</h3><p>方法一：一次赋一个值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array[0]=&#x27;tom&#x27;</span><br><span class="line">array[1]=&#x27;jarry&#x27;</span><br><span class="line">array[2]=&#x27;natasha&#x27;</span><br></pre></td></tr></table></figure><p>方法二：一次赋多个值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array2=(tom jack alice)</span><br><span class="line">array3=(`cat /etc/passwd`) #希望是将该文件中的每一个行作为一个元素赋值给数组array</span><br></pre></td></tr></table></figure><h3 id="1-4查看数组"><a href="#1-4查看数组" class="headerlink" title="1.4查看数组"></a>1.4查看数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare -a</span><br><span class="line">declare -a array1=&#x27;([0]=&quot;pear&quot; [1]=&quot;apple&quot; [2]=&quot;orange&quot;)&#x27;</span><br></pre></td></tr></table></figure><h3 id="1-5访问数组元素"><a href="#1-5访问数组元素" class="headerlink" title="1.5访问数组元素"></a>1.5访问数组元素</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;array1[0]&#125; 访问数组中的第一个元素</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[@] 访问数组中的所有元素 等同于echo $&#123;array1[*]&#125;</span><br><span class="line"></span><br><span class="line">echo $&#123;#array1[@]&#125; 统计数组元素的个数</span><br><span class="line"></span><br><span class="line">echo $&#123;!array1[@]&#125; 获取数组元素的索引</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[@]:1&#125; 从数组下标1开始</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[@]:1:2&#125; 从数组下标1开始， 访问两个元素</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-6-遍历数组"><a href="#1-6-遍历数组" class="headerlink" title="1.6 遍历数组"></a>1.6 遍历数组</h3><p>默认数组通过数组元素的个数进行遍历</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;array[0]&#125;</span><br></pre></td></tr></table></figure><p>方法二：针对关联数组可以通过数组的索引进行遍历</p><h2 id="二、关联数组"><a href="#二、关联数组" class="headerlink" title="二、关联数组"></a>二、关联数组</h2><h3 id="2-1-定义关联数组"><a href="#2-1-定义关联数组" class="headerlink" title="2.1 定义关联数组"></a>2.1 定义关联数组</h3><p>声明关联数组变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare -A ass_array1</span><br><span class="line">declare -A ass_array2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/post/50daec4.html"/>
      <url>/post/50daec4.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo aaa;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
